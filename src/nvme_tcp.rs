/* automatically generated by rust-bindgen 0.69.4 */

pub const NVME_TCP_DISC_PORT: u32 = 8009;
pub const NVME_TCP_DIGEST_LENGTH: u32 = 4;
pub type __u8 = ::std::os::raw::c_uchar;
pub type __u16 = ::std::os::raw::c_ushort;
pub type __u32 = ::std::os::raw::c_uint;
pub type __u64 = ::std::os::raw::c_ulonglong;
pub type __le16 = __u16;
pub type __le32 = __u32;
pub type __le64 = __u64;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nvme_sgl_desc {
    pub addr: __le64,
    pub length: __le32,
    pub rsvd: [__u8; 3usize],
    pub type_: __u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nvme_keyed_sgl_desc {
    pub addr: __le64,
    pub length: [__u8; 3usize],
    pub key: [__u8; 4usize],
    pub type_: __u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union nvme_data_ptr {
    pub __bindgen_anon_1: nvme_data_ptr__bindgen_ty_1,
    pub sgl: nvme_sgl_desc,
    pub ksgl: nvme_keyed_sgl_desc,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nvme_data_ptr__bindgen_ty_1 {
    pub prp1: __le64,
    pub prp2: __le64,
}
impl Default for nvme_data_ptr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvme_common_command {
    pub opcode: __u8,
    pub flags: __u8,
    pub command_id: __u16,
    pub nsid: __le32,
    pub cdw2: [__le32; 2usize],
    pub metadata: __le64,
    pub dptr: nvme_data_ptr,
    pub cdw10: __le32,
    pub cdw11: __le32,
    pub cdw12: __le32,
    pub cdw13: __le32,
    pub cdw14: __le32,
    pub cdw15: __le32,
}
impl Default for nvme_common_command {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvme_rw_command {
    pub opcode: __u8,
    pub flags: __u8,
    pub command_id: __u16,
    pub nsid: __le32,
    pub rsvd2: __u64,
    pub metadata: __le64,
    pub dptr: nvme_data_ptr,
    pub slba: __le64,
    pub length: __le16,
    pub control: __le16,
    pub dsmgmt: __le32,
    pub reftag: __le32,
    pub apptag: __le16,
    pub appmask: __le16,
}
impl Default for nvme_rw_command {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvme_dsm_cmd {
    pub opcode: __u8,
    pub flags: __u8,
    pub command_id: __u16,
    pub nsid: __le32,
    pub rsvd2: [__u64; 2usize],
    pub dptr: nvme_data_ptr,
    pub nr: __le32,
    pub attributes: __le32,
    pub rsvd12: [__u32; 4usize],
}
impl Default for nvme_dsm_cmd {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvme_write_zeroes_cmd {
    pub opcode: __u8,
    pub flags: __u8,
    pub command_id: __u16,
    pub nsid: __le32,
    pub rsvd2: __u64,
    pub metadata: __le64,
    pub dptr: nvme_data_ptr,
    pub slba: __le64,
    pub length: __le16,
    pub control: __le16,
    pub dsmgmt: __le32,
    pub reftag: __le32,
    pub apptag: __le16,
    pub appmask: __le16,
}
impl Default for nvme_write_zeroes_cmd {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvme_zone_mgmt_send_cmd {
    pub opcode: __u8,
    pub flags: __u8,
    pub command_id: __u16,
    pub nsid: __le32,
    pub cdw2: [__le32; 2usize],
    pub metadata: __le64,
    pub dptr: nvme_data_ptr,
    pub slba: __le64,
    pub cdw12: __le32,
    pub zsa: __u8,
    pub select_all: __u8,
    pub rsvd13: [__u8; 2usize],
    pub cdw14: [__le32; 2usize],
}
impl Default for nvme_zone_mgmt_send_cmd {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvme_zone_mgmt_recv_cmd {
    pub opcode: __u8,
    pub flags: __u8,
    pub command_id: __u16,
    pub nsid: __le32,
    pub rsvd2: [__le64; 2usize],
    pub dptr: nvme_data_ptr,
    pub slba: __le64,
    pub numd: __le32,
    pub zra: __u8,
    pub zrasf: __u8,
    pub pr: __u8,
    pub rsvd13: __u8,
    pub cdw14: [__le32; 2usize],
}
impl Default for nvme_zone_mgmt_recv_cmd {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvme_identify {
    pub opcode: __u8,
    pub flags: __u8,
    pub command_id: __u16,
    pub nsid: __le32,
    pub rsvd2: [__u64; 2usize],
    pub dptr: nvme_data_ptr,
    pub cns: __u8,
    pub rsvd3: __u8,
    pub ctrlid: __le16,
    pub rsvd11: [__u8; 3usize],
    pub csi: __u8,
    pub rsvd12: [__u32; 4usize],
}
impl Default for nvme_identify {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvme_features {
    pub opcode: __u8,
    pub flags: __u8,
    pub command_id: __u16,
    pub nsid: __le32,
    pub rsvd2: [__u64; 2usize],
    pub dptr: nvme_data_ptr,
    pub fid: __le32,
    pub dword11: __le32,
    pub dword12: __le32,
    pub dword13: __le32,
    pub dword14: __le32,
    pub dword15: __le32,
}
impl Default for nvme_features {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nvme_create_cq {
    pub opcode: __u8,
    pub flags: __u8,
    pub command_id: __u16,
    pub rsvd1: [__u32; 5usize],
    pub prp1: __le64,
    pub rsvd8: __u64,
    pub cqid: __le16,
    pub qsize: __le16,
    pub cq_flags: __le16,
    pub irq_vector: __le16,
    pub rsvd12: [__u32; 4usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nvme_create_sq {
    pub opcode: __u8,
    pub flags: __u8,
    pub command_id: __u16,
    pub rsvd1: [__u32; 5usize],
    pub prp1: __le64,
    pub rsvd8: __u64,
    pub sqid: __le16,
    pub qsize: __le16,
    pub sq_flags: __le16,
    pub cqid: __le16,
    pub rsvd12: [__u32; 4usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nvme_delete_queue {
    pub opcode: __u8,
    pub flags: __u8,
    pub command_id: __u16,
    pub rsvd1: [__u32; 9usize],
    pub qid: __le16,
    pub rsvd10: __u16,
    pub rsvd11: [__u32; 5usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nvme_abort_cmd {
    pub opcode: __u8,
    pub flags: __u8,
    pub command_id: __u16,
    pub rsvd1: [__u32; 9usize],
    pub sqid: __le16,
    pub cid: __u16,
    pub rsvd11: [__u32; 5usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvme_download_firmware {
    pub opcode: __u8,
    pub flags: __u8,
    pub command_id: __u16,
    pub rsvd1: [__u32; 5usize],
    pub dptr: nvme_data_ptr,
    pub numd: __le32,
    pub offset: __le32,
    pub rsvd12: [__u32; 4usize],
}
impl Default for nvme_download_firmware {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nvme_format_cmd {
    pub opcode: __u8,
    pub flags: __u8,
    pub command_id: __u16,
    pub nsid: __le32,
    pub rsvd2: [__u64; 4usize],
    pub cdw10: __le32,
    pub rsvd11: [__u32; 5usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvme_get_log_page_command {
    pub opcode: __u8,
    pub flags: __u8,
    pub command_id: __u16,
    pub nsid: __le32,
    pub rsvd2: [__u64; 2usize],
    pub dptr: nvme_data_ptr,
    pub lid: __u8,
    pub lsp: __u8,
    pub numdl: __le16,
    pub numdu: __le16,
    pub rsvd11: __u16,
    pub __bindgen_anon_1: nvme_get_log_page_command__bindgen_ty_1,
    pub rsvd14: [__u8; 3usize],
    pub csi: __u8,
    pub rsvd15: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union nvme_get_log_page_command__bindgen_ty_1 {
    pub __bindgen_anon_1: nvme_get_log_page_command__bindgen_ty_1__bindgen_ty_1,
    pub lpo: __le64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nvme_get_log_page_command__bindgen_ty_1__bindgen_ty_1 {
    pub lpol: __le32,
    pub lpou: __le32,
}
impl Default for nvme_get_log_page_command__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for nvme_get_log_page_command {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvme_directive_cmd {
    pub opcode: __u8,
    pub flags: __u8,
    pub command_id: __u16,
    pub nsid: __le32,
    pub rsvd2: [__u64; 2usize],
    pub dptr: nvme_data_ptr,
    pub numd: __le32,
    pub doper: __u8,
    pub dtype: __u8,
    pub dspec: __le16,
    pub endir: __u8,
    pub tdtype: __u8,
    pub rsvd15: __u16,
    pub rsvd16: [__u32; 3usize],
}
impl Default for nvme_directive_cmd {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmf_common_command {
    pub opcode: __u8,
    pub resv1: __u8,
    pub command_id: __u16,
    pub fctype: __u8,
    pub resv2: [__u8; 35usize],
    pub ts: [__u8; 24usize],
}
impl Default for nvmf_common_command {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmf_connect_command {
    pub opcode: __u8,
    pub resv1: __u8,
    pub command_id: __u16,
    pub fctype: __u8,
    pub resv2: [__u8; 19usize],
    pub dptr: nvme_data_ptr,
    pub recfmt: __le16,
    pub qid: __le16,
    pub sqsize: __le16,
    pub cattr: __u8,
    pub resv3: __u8,
    pub kato: __le32,
    pub resv4: [__u8; 12usize],
}
impl Default for nvmf_connect_command {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmf_property_set_command {
    pub opcode: __u8,
    pub resv1: __u8,
    pub command_id: __u16,
    pub fctype: __u8,
    pub resv2: [__u8; 35usize],
    pub attrib: __u8,
    pub resv3: [__u8; 3usize],
    pub offset: __le32,
    pub value: __le64,
    pub resv4: [__u8; 8usize],
}
impl Default for nvmf_property_set_command {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmf_property_get_command {
    pub opcode: __u8,
    pub resv1: __u8,
    pub command_id: __u16,
    pub fctype: __u8,
    pub resv2: [__u8; 35usize],
    pub attrib: __u8,
    pub resv3: [__u8; 3usize],
    pub offset: __le32,
    pub resv4: [__u8; 16usize],
}
impl Default for nvmf_property_get_command {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nvme_dbbuf {
    pub opcode: __u8,
    pub flags: __u8,
    pub command_id: __u16,
    pub rsvd1: [__u32; 5usize],
    pub prp1: __le64,
    pub prp2: __le64,
    pub rsvd12: [__u32; 6usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvme_command {
    pub __bindgen_anon_1: nvme_command__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union nvme_command__bindgen_ty_1 {
    pub common: nvme_common_command,
    pub rw: nvme_rw_command,
    pub identify: nvme_identify,
    pub features: nvme_features,
    pub create_cq: nvme_create_cq,
    pub create_sq: nvme_create_sq,
    pub delete_queue: nvme_delete_queue,
    pub dlfw: nvme_download_firmware,
    pub format: nvme_format_cmd,
    pub dsm: nvme_dsm_cmd,
    pub write_zeroes: nvme_write_zeroes_cmd,
    pub zms: nvme_zone_mgmt_send_cmd,
    pub zmr: nvme_zone_mgmt_recv_cmd,
    pub abort: nvme_abort_cmd,
    pub get_log_page: nvme_get_log_page_command,
    pub fabrics: nvmf_common_command,
    pub connect: nvmf_connect_command,
    pub prop_set: nvmf_property_set_command,
    pub prop_get: nvmf_property_get_command,
    pub dbbuf: nvme_dbbuf,
    pub directive: nvme_directive_cmd,
}
impl Default for nvme_command__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for nvme_command {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvme_completion {
    pub result: nvme_completion_nvme_result,
    pub sq_head: __le16,
    pub sq_id: __le16,
    pub command_id: __u16,
    pub status: __le16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union nvme_completion_nvme_result {
    pub u16_: __le16,
    pub u32_: __le32,
    pub u64_: __le64,
}
impl Default for nvme_completion_nvme_result {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for nvme_completion {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const nvme_tcp_pfv_NVME_TCP_PFV_1_0: nvme_tcp_pfv = 0;
pub type nvme_tcp_pfv = ::std::os::raw::c_uint;
pub const nvme_tcp_fatal_error_status_NVME_TCP_FES_INVALID_PDU_HDR: nvme_tcp_fatal_error_status = 1;
pub const nvme_tcp_fatal_error_status_NVME_TCP_FES_PDU_SEQ_ERR: nvme_tcp_fatal_error_status = 2;
pub const nvme_tcp_fatal_error_status_NVME_TCP_FES_HDR_DIGEST_ERR: nvme_tcp_fatal_error_status = 3;
pub const nvme_tcp_fatal_error_status_NVME_TCP_FES_DATA_OUT_OF_RANGE: nvme_tcp_fatal_error_status =
    4;
pub const nvme_tcp_fatal_error_status_NVME_TCP_FES_R2T_LIMIT_EXCEEDED: nvme_tcp_fatal_error_status =
    5;
pub const nvme_tcp_fatal_error_status_NVME_TCP_FES_DATA_LIMIT_EXCEEDED:
    nvme_tcp_fatal_error_status = 5;
pub const nvme_tcp_fatal_error_status_NVME_TCP_FES_UNSUPPORTED_PARAM: nvme_tcp_fatal_error_status =
    6;
pub type nvme_tcp_fatal_error_status = ::std::os::raw::c_uint;
pub const nvme_tcp_digest_option_NVME_TCP_HDR_DIGEST_ENABLE: nvme_tcp_digest_option = 1;
pub const nvme_tcp_digest_option_NVME_TCP_DATA_DIGEST_ENABLE: nvme_tcp_digest_option = 2;
pub type nvme_tcp_digest_option = ::std::os::raw::c_uint;
pub const nvme_tcp_pdu_type_nvme_tcp_icreq: nvme_tcp_pdu_type = 0;
pub const nvme_tcp_pdu_type_nvme_tcp_icresp: nvme_tcp_pdu_type = 1;
pub const nvme_tcp_pdu_type_nvme_tcp_h2c_term: nvme_tcp_pdu_type = 2;
pub const nvme_tcp_pdu_type_nvme_tcp_c2h_term: nvme_tcp_pdu_type = 3;
pub const nvme_tcp_pdu_type_nvme_tcp_cmd: nvme_tcp_pdu_type = 4;
pub const nvme_tcp_pdu_type_nvme_tcp_rsp: nvme_tcp_pdu_type = 5;
pub const nvme_tcp_pdu_type_nvme_tcp_h2c_data: nvme_tcp_pdu_type = 6;
pub const nvme_tcp_pdu_type_nvme_tcp_c2h_data: nvme_tcp_pdu_type = 7;
pub const nvme_tcp_pdu_type_nvme_tcp_r2t: nvme_tcp_pdu_type = 9;
pub type nvme_tcp_pdu_type = ::std::os::raw::c_uint;
pub const nvme_tcp_pdu_flags_NVME_TCP_F_HDGST: nvme_tcp_pdu_flags = 1;
pub const nvme_tcp_pdu_flags_NVME_TCP_F_DDGST: nvme_tcp_pdu_flags = 2;
pub const nvme_tcp_pdu_flags_NVME_TCP_F_DATA_LAST: nvme_tcp_pdu_flags = 4;
pub const nvme_tcp_pdu_flags_NVME_TCP_F_DATA_SUCCESS: nvme_tcp_pdu_flags = 8;
pub type nvme_tcp_pdu_flags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nvme_tcp_hdr {
    pub type_: __u8,
    pub flags: __u8,
    pub hlen: __u8,
    pub pdo: __u8,
    pub plen: __le32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvme_tcp_icreq_pdu {
    pub hdr: nvme_tcp_hdr,
    pub pfv: __le16,
    pub hpda: __u8,
    pub digest: __u8,
    pub maxr2t: __le32,
    pub rsvd2: [__u8; 112usize],
}
impl Default for nvme_tcp_icreq_pdu {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvme_tcp_icresp_pdu {
    pub hdr: nvme_tcp_hdr,
    pub pfv: __le16,
    pub cpda: __u8,
    pub digest: __u8,
    pub maxdata: __le32,
    pub rsvd: [__u8; 112usize],
}
impl Default for nvme_tcp_icresp_pdu {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nvme_tcp_term_pdu {
    pub hdr: nvme_tcp_hdr,
    pub fes: __le16,
    pub feil: __le16,
    pub feiu: __le16,
    pub rsvd: [__u8; 10usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvme_tcp_cmd_pdu {
    pub hdr: nvme_tcp_hdr,
    pub cmd: nvme_command,
}
impl Default for nvme_tcp_cmd_pdu {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvme_tcp_rsp_pdu {
    pub hdr: nvme_tcp_hdr,
    pub cqe: nvme_completion,
}
impl Default for nvme_tcp_rsp_pdu {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nvme_tcp_r2t_pdu {
    pub hdr: nvme_tcp_hdr,
    pub command_id: __u16,
    pub ttag: __u16,
    pub r2t_offset: __le32,
    pub r2t_length: __le32,
    pub rsvd: [__u8; 4usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nvme_tcp_data_pdu {
    pub hdr: nvme_tcp_hdr,
    pub command_id: __u16,
    pub ttag: __u16,
    pub data_offset: __le32,
    pub data_length: __le32,
    pub rsvd: [__u8; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union nvme_tcp_pdu {
    pub icreq: nvme_tcp_icreq_pdu,
    pub icresp: nvme_tcp_icresp_pdu,
    pub cmd: nvme_tcp_cmd_pdu,
    pub rsp: nvme_tcp_rsp_pdu,
    pub r2t: nvme_tcp_r2t_pdu,
    pub data: nvme_tcp_data_pdu,
}
impl Default for nvme_tcp_pdu {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
